<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">


<!-- Mirrored from www.python-course.eu/python3_sets_frozensets.php by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 14 Dec 2014 20:08:22 GMT -->
<head>

<!-- Dieses Tag in den Head-Bereich oder direkt vor dem schlieÃŸenden Body-Tag einfÃ¼gen -->
<script type="text/javascript" src="../apis.google.com/js/plusone.js"></script>



<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "../connect.facebook.net/en_GB/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script><title>Python3 Tutorial: Sets and Frozen Sets</title>
<meta http-equiv="content-type" content="text/html; charset="ISO-8859-1">
<meta name="Description" content="Even though sets have been used in Python since  2.3, Python3 has finally implemented them uniformly." />
<meta name="Keywords" content="Python, course, sets, frozen sets" />

<link href="favicon.ico" rel="shortcut icon">

<link href="moderna.css" rel="stylesheet" type="text/css" />
<link href="moderna_print.css" media="print" rel="stylesheet" type="text/css" />

</head>

<body>

<div id="container">

<div id="banner">
<!-- <a href="impressum.php">Impressum</a> | <a href="mailto:">contact</a> | --><h1>Python Course</h1>

</div>

	<!-- Begin Top Menu -->
<ul id="navlist">
<li><a href="index-2.html" >Home</a></li><li><a href="course.html" >Python 2 Tutorial</a></li><li class="active"><a id="current" href="python3_course.html" >Python 3 Tutorial</a></li><li><a href="advanced_topics.html" >Advanced Topics</a></li><li><a href="python_books.html" >Python Books</a></li><li><a href="python_tkinter.html" >Tkinter Tutorial</a></li><li><a href="contact.html" rel="nofollow">Contact</a></li>                          
</ul>
	<!-- End Top Menu -->
<div id="sidebar-a">
<img class="border" src="images/blocks100.jpg" alt="box" />    <h2>Python 3 Tutorial</h2>

<div class="menu">

<ul>
<li><a href="python3_history_and_philosophy.html">The Origins of Python</a></li><li><a href="python3_interactive.html">Starting with Python: The Interactive Shell</a></li><li><a href="python3_execute_script.html">Executing a Script</a></li><li><a href="python3_blocks.html">Indentation</a></li><li><a href="python3_variables.html">Data Types and Variables</a></li><li><a href="python3_operators.html">Operators</a></li><li><a href="python3_sequential_data_types.html">Sequential Data Types: Lists and Strings</a></li><li><a href="python3_deep_copy.html">Shallow and Deep Copy</a></li><li><a href="python3_dictionaries.html">Dictionaries</a></li><li><a href="python3_sets_frozensets.html">Sets and Frozen Sets</a></li><li><a href="python3_input.html">input via the keyboard</a></li><li><a href="python3_conditional_statements.html">Conditional Statements</a></li><li><a href="python3_loops.html">Loops, while Loop</a></li><li><a href="python3_for_loop.html">For Loops</a></li><li><a href="python3_print.html">Output with Print</a></li><li><a href="python3_formatted_output.html">Formatted output with string modulo and the format method</a></li><li><a href="python3_functions.html">Functions</a></li><li><a href="python3_recursive_functions.html">Recursion and Recursive Functions</a></li><li><a href="python3_tests.html">Tests, DocTests, UnitTests</a></li><li><a href="python3_memoization.html">Memoization and Decorators</a></li><li><a href="python3_passing_arguments.html">Parameter Passing in Functions</a></li><li><a href="python3_namespaces.html">Namespaces</a></li><li><a href="python3_global_vs_local_variables.html">Global and Local Variables</a></li><li><a href="python3_file_management.html">Read and Write Files</a></li><li><a href="python3_modules_and_modular_programming.html">Modular Programming and Modules</a></li><li><a href="python3_re.html">Regular Expressions</a></li><li><a href="python3_re_advanced.html">Regular Expressions, Advanced</a></li><li><a href="python3_lambda.html">Lambda Operator, Filter, Reduce and Map</a></li><li><a href="python3_list_comprehension.html">List Comprehension</a></li><li><a href="python3_generators.html">Iterators and Generators</a></li><li><a href="python3_exception_handling.html">Exception Handling</a></li><li><a href="python3_object_oriented_programming.html">Object Oriented Programming</a></li><li><a href="python3_class_and_instance_attributes.html">Class and Instance Attributes</a></li><li><a href="python3_properties.html">Properties vs. getters and setters</a></li><li><a href="python3_inheritance.html">Inheritance</a></li><li><a href="python3_multiple_inheritance.html">Multiple Inheritance</a></li><li><a href="python3_magic_methods.html">Magic Methods and Operator Overloading</a></li><li><a href="python3_inheritance_example.html">OOP, Inheritance Example</a></li></ul>

</div>

<p>
<h3>Russell's paradox</h3>
The set of all sets that are not members of themselves". This is a contradiction 
since this set must be both a member of itself, and not a member of itself. 
<hr>
<br>
This website is created by:<br><br>
<a href="http://www.python-training-courses.com/"><img style="width: 150px;" alt="Python Training Courses"
		     src="images/toronto_building.jpg"><br><br>Python Training Courses in Toronto, Canada</a>
<br>
On site trainings in Europe, Canada and the US.
<br>
<hr>
</div><div id="sidebar-b"><img style="width: 150px;" alt="Python-Logo"
		     src="images/python-logo.png"><!-- Dieses Tag dort einfügen, wo die +1-Schaltfläche dargestellt werden soll -->
<g:plusone></g:plusone>
<br><br>

<div class="fb-like" data-href="www.python-course.eu" data-send="false" data-layout="button_count" 
data-width="130" data-show-faces="true" data-action="recommend"></div>

<br><br>
This topic in German / Deutsche Übersetzung:
    <a href="http://www.python-kurs.eu/python3_sets_mengen.php">Mengen</a><h3>Python3</h3>This is a tutorial in Python3, but this chapter of our course is available in a version for Python 2.x as well: <a href="sets_frozensets.html">Sets and Frozen Sets in Python 2.x</a><p>
<h3>Classroom Training Courses</h3>
The goal of this website is to provide educational material, 
allowing you to learn Python on your own.
Nevertheless, it is faster and more efficient to attend a "real" 
Python course in a classroom, with
an experienced trainer. So why not attend one of the live 
<a href="python_classes.html">Python courses</a> in Paris, London, Berlin, Munich
or Lake Constance by Bernd Klein, the author of this tutorial?
<br><br>
You can also check the   
<a href="http://www.bodenseo.com/courses.php?topic=Python">Python Training courses
<img style="width: 150px;" alt="Bodenseo Kurse in Python"
		     src="images/bodenseo_stairs_to_python.png"></a>
		     delivered by Bodenseo and Bernd Klein.
<br><br>
You can book on-site classes at your company or organization, e.g. in England, Switzerland, Austria, Germany,
France, Belgium, the Netherlands, Luxembourg, Poland, UK, Italy and other locations in Europe.
<br><br>
<h3>Python3</h3>This is a tutorial in Python3, but this chapter of our course is available in a version for Python 2.x as well: <a href="sets_frozensets.html">Sets and Frozen Sets in Python 2.x</a>
 </p>




    
</p></div>
<div id="content">

<div id="contextlinks">Previous Chapter: <a href="python3_dictionaries.html">Dictionaries</a><br>
<LINK rel="prev" href="python3_dictionaries.html">Next Chapter: <a href="python3_input.html">input via the keyboard</a><br>
<LINK rel="next" href="python3_input.html"></div>
<h2>Sets and Frozensets</h2>
<br><br>
<p>
<h3>Introduction</h3>
<img class="imgright" src="images/sets_with_notations.png" alt="Graphical Depiction of Sets as Circles" />
In this chapter of our tutorial, we are dealing with Python's implementation of sets. Though
sets are nowadays an integral part of modern mathematics, this has not always been like this. The
set theory had been rejected by many, even great thinkers. One of them was the philosopher Wittgenstein 
He didn't like the set theory and complained mathematics is "ridden 
through and through with the pernicious idioms of set theory..."
He dismissed the set theory as "utter nonsense", as being "laughable" and "wrong". His criticism
appeared years after the death of the German mathematician Georg Cantor, the founder of the set
theory.
David Hilbert defended it from its critics by famously declaring: "No one shall expel us from the Paradise that Cantor has created.
<br><br>
Cantor defined a set at the beginning of his "Beiträge zur BegrÃündung der transfiniten 
Mengenlehre":
<br>
<i>"A set is a gathering together into a whole of definite, distinct objects of our perception
 and of our thought - which are called elements of the set."</i>
Nowadays, we can say in "plain" English: A set is a well defined collection of objects.
<br><br>
The elements or members of a set can be anything: numbers, characters, words, names, 
letters of the alphabet, even other sets, and so on. 
Sets are usually denoted with capital letters. This is not the exact methematical
definition, but it is good enough for the following.
<br><br>
The data type "set", which is a collection type, has been part of Python since 
version 2.4. A set contains an unordered collection of unique and immutable objects.
The set data type is, as the name implies, a Python implementation of the sets as
they are known from mathematics. This explains, why sets unlike lists or tuples can't 
have multiple occurrences of the same element.

<h3>Sets</h3>    
If we want to create a set, we can call the built-in set function with a sequence or
another iterable object:

<br><br>
In the following example, a string is singularised into its characters to build the resulting
set x: 

<pre>
>>> x = set("A Python Tutorial")
>>> x
{'A', ' ', 'i', 'h', 'l', 'o', 'n', 'P', 'r', 'u', 't', 'a', 'y', 'T'}
>>> type(x)
<class 'set'>
>>> 
</pre>
<br><br>
We can pass a list to the built-in set function, as we can see in the following:
<br><br>
<pre>
>>> x = set(["Perl", "Python", "Java"])
>>> x
{'Python', 'Java', 'Perl'}
>>> 
</pre>
<br>
<br>
We want to show now, what happens, if we pass a tuple with reappearing elements to the
set function - in our
example the city "Paris":
<br><br>
<pre>
>>> cities = set(("Paris", "Lyon", "London","Berlin","Paris","Birmingham"))
>>> cities
{'Paris', 'Birmingham', 'Lyon', 'London', 'Berlin'}
>>> 
</pre>
<br><br>
As we have expected, no doublets are in the resulting set of cities.

<h3>Immutable Sets</h3>
Sets are implemented in a way, which doesn't allow mutable objects. The following
example demonstrates, that we cannot include for example lists as elements:

<pre>
>>> cities = set((("Python","Perl"), ("Paris", "Berlin", "London")))
>>> cities = set((["Python","Perl"], ["Paris", "Berlin", "London"]))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'list'
>>> 
</pre>
<br><br>
<h3>Frozensets</h3>
Though sets can't contain mutable objects, sets are mutable:
<br>
<pre>
>>> cities = set(["Frankfurt", "Basel","Freiburg"])
>>> cities.add("Strasbourg")
>>> cities
{'Freiburg', 'Basel', 'Frankfurt', 'Strasbourg'}
>>> 
</pre> 
<br>
Frozensets are like sets except, that they cannot be changed, i.e. they are immutable:
<pre>
>>> cities = frozenset(["Frankfurt", "Basel","Freiburg"])
>>> cities.add("Strasbourg")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'frozenset' object has no attribute 'add'
>>> 
</pre>
<br><br>
<h3>Improved notation</h3>
We can define sets (since Python2.6) without using the built-in set function. We can use
curly braces instead:
<br>
<pre>
>>> adjectives = {"cheap","expensive","inexpensive","economical"}
>>> adjectives
{'inexpensive', 'cheap', 'expensive', 'economical'}
>>> 
</pre>
<br>
<h3>Set Operations</h3>

<dl>
	<dt><h4>add(element)</h4></dt>
	<dd>A method which adds an element, which has to be immutable, to a set.
<pre>
>>> colours = {"red","green"}
>>> colours.add("yellow")
>>> colours
{'green', 'yellow', 'red'}
>>> colours.add(["black","white"])
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'list'
>>> 
</pre>	
Of course, an element will only be added, if it is not already contained in the set. If it is
already contained, the method call has no effect.
	</dd>

	<dt><h4>clear()</h4></dt>
	<dd>All elements will removed from a set.
<pre>
>>> cities = {"Stuttgart", "Konstanz", "Freiburg"}
>>> cities.clear()
>>> cities
set()
>>> 
</pre>	
	</dd>
	
   <dt><h4>copy</h4></dt>
	<dd>
	Creates a shallow copy, which is returned.
	<pre>
>>> more_cities = {"Winterthur","Schaffhausen","St. Gallen"}
>>> cities_backup = more_cities.copy()
>>> more_cities.clear()
>>> cities_backup
{'St. Gallen', 'Winterthur', 'Schaffhausen'}
>>> 
</pre>
<br>
Just in case, you might think, an assignment might be enough:
<pre>
>>> more_cities = {"Winterthur","Schaffhausen","St. Gallen"}
>>> cities_backup = more_cities
>>> more_cities.clear()
>>> cities_backup
set()
>>> 
	</pre>	
The assignment "cities_backup = more_cities" just creates a pointer, i.e. another name,
to the same data structure.
	</dd>

	<dt><h4>difference()</h4></dt>
	<dd>
This method returns the difference of two or more sets as a new set.	
	<pre>
>>> x = {"a","b","c","d","e"}
>>> y = {"b","c"}
>>> z = {"c","d"}
>>> x.difference(y)
{'a', 'e', 'd'}
>>> x.difference(y).difference(z)
{'a', 'e'}
>>> 
</pre>
Instead of using the method difference, we can use the operator "-":
<pre>
>>> x - y
{'a', 'e', 'd'}
>>> x - y - z
{'a', 'e'}
>>> 	
	</pre>
	</dd>
	
	<dt><h4>difference_update()</h4></dt>
	<dd>
	The method difference_update removes all elements of another set from this set.
   x.difference_update() is the same as "x = x - y"	

	<pre>
>>> x = {"a","b","c","d","e"}
>>> y = {"b","c"}
>>> x.difference_update(y)
>>> 
>>> x = {"a","b","c","d","e"}
>>> y = {"b","c"}
>>> x = x - y
>>> x
{'a', 'e', 'd'}
>>> 	
	</pre>
	</dd>

	<dt><h4>discard(el)</h4></dt>
	<dd>An element el will be removed from the set, if it is contained in the set.
	If el is not a member of the set, nothing will be done.
	<pre>
>>> x = {"a","b","c","d","e"}
>>> x.discard("a")
>>> x
{'c', 'b', 'e', 'd'}
>>> x.discard("z")
>>> x
{'c', 'b', 'e', 'd'}
>>> 	
	</pre>	
	</dd>
	
	<dt><h4>remove(el)</h4></dt>
	<dd>works like discard(), but if el is not a member of the set, a KeyError will be
	raised.
	<pre>
	>>> x = {"a","b","c","d","e"}
>>> x.remove("a")
>>> x
{'c', 'b', 'e', 'd'}
>>> x.remove("z")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: 'z'
>>> 	
	</pre>	
	 </dd>
	
	<dt><h4>intersection(s)</h4></dt>
	<dd>
	Returns the intersection of the instance set and the set s as a new set. In other
	words: A set with all the elements which are contained in both sets is returned.
<pre>
>>> x = {"a","b","c","d","e"}
>>> y = {"c","d","e","f","g"}
>>> x.intersection(y)
{'c', 'e', 'd'}
>>> 
</pre>	
This can be abbreviated with the ampersand operator "&":
<pre>
>>> x = {"a","b","c","d","e"}
>>> y = {"c","d","e","f","g"}
>>> x.intersection(y)
{'c', 'e', 'd'}
>>> 
>>> x = {"a","b","c","d","e"}
>>> y = {"c","d","e","f","g"}
>>> x  & y
{'c', 'e', 'd'}
>>> 
</pre>	
	</dd>
	
	<dt><h4>isdisjoint()</h4></dt>
	<dd>This method returns True if two sets have a null intersection.	
	</dd>
	
	<dt><h4>issubset()</h4></dt>
	<dd>
	x.issubset(y) returns True, if x is a subset of y. "<=" is an abbreviation for "Subset of"	and ">="
	for "superset of" 
<br>"<" is used to check if a set is a proper subset of a set.
	<pre>
>>> x = {"a","b","c","d","e"}
>>> y = {"c","d"}
>>> x.issubset(y)
False
>>> y.issubset(x)
True
>>> x < y
False
>>> y < x # y is a proper subset of x
True
>>> x < x # a set can never be a proper subset of oneself.
False
>>> x <= x 
True
>>> 
	</pre>
	</dd>

	<dt><h4>issuperset()</h4></dt>
	<dd>x.issuperset(y) returns True, if x is a superset of y. ">=" is an abbreviation for "issuperset of" 
<br>">" is used to check if a set is a proper superset of a set.
<br>
<pre>
>>> x = {"a","b","c","d","e"}
>>> y = {"c","d"}
>>> x.issuperset(y)
True
>>> x > y
True
>>> x >= y
True
>>> x >= x
True
>>> x > x
False
>>> x.issuperset(x)
True
>>> 
</pre>	
</dd>
	
	<dt><h4>pop()</h4></dt>
	<dd>pop() removes and returns an arbitrary set element. The method raises a KeyError
	if the set is empty

<pre>
>>> x = {"a","b","c","d","e"}
>>> x.pop()
'a'
>>> x.pop()
'c'
</pre>	
	
	</dd>

</dl>

<br><br>
<div id="contextlinks">Previous Chapter: <a href="python3_dictionaries.html">Dictionaries</a><br>
<LINK rel="prev" href="python3_dictionaries.html">Next Chapter: <a href="python3_input.html">input via the keyboard</a><br>
<LINK rel="next" href="python3_input.html"></div><br><br><br>

</div>
<div id="footer">  &copy; 2011 - 2014 <a href="http://www.bklein.de/">Bernd Klein</a>,
Bodenseo; 
Design by Denise Mitchinson adapted for python-course.eu by Bernd Klein</div>
</div>
</body>

<!-- Mirrored from www.python-course.eu/python3_sets_frozensets.php by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 14 Dec 2014 20:08:22 GMT -->
</html>
